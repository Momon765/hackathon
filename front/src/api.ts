/**
 * Generated by orval v6.29.1 🍺
 * Do not edit manually.
 * Gohan Schema
 * ハッカソンのスキーマ
 * OpenAPI spec version: 1.0.11
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import {
  useCallback
} from 'react'
import {
  faker
} from '@faker-js/faker'
import {
  HttpResponse,
  delay,
  http
} from 'msw'
import { customInstance } from './axiosInstance';
import type { ErrorType, BodyType } from './axiosInstance';
export type CallbackParams = {
/**
 * コード
 */
code: string;
};

export type GetLoginUrlResponse = LoginUrl;

export interface JoinEventResponse {
  event?: Event;
}

export interface JoinEventRequest {
  user_id: number;
}

export interface GetEmploymentTypesResponse {
  employmentTypes: EmploymentType[];
}

export interface GetRolesResponse {
  roles: Role[];
}

export interface GetDepartmentsResponse {
  departments: Department[];
}

export interface GetRestaurantsResponse {
  restaurants: Restaurant[];
}

/**
 * 0: 男性, 1: 女性, 2: その他
 */
export type PutUserRequestSex = typeof PutUserRequestSex[keyof typeof PutUserRequestSex];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutUserRequestSex = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface PutUserRequest {
  /** 自己紹介 */
  description?: string;
  employment_type_id?: number;
  role_id?: number;
  /** 0: 男性, 1: 女性, 2: その他 */
  sex?: PutUserRequestSex;
}

export interface GetUserResponse {
  user: User;
}

export interface GetEventResponse {
  event: Event;
}

export interface PostEventRequest {
  deadline?: string;
  description?: string;
  employment_type_ids?: number[];
  end_date?: string;
  is_anonymous?: boolean;
  limit?: number;
  restaurant?: string;
  role_ids?: number[];
  scope_sex?: number;
  start_date?: string;
  title?: string;
}

export interface GetEventsResponse {
  events: Event[];
}

export interface ServerError {
  message: string;
  status: number;
}

export interface AuthError {
  message: string;
  status: number;
}

export type ClientErrorDetails = { [key: string]: any };

export interface ClientError {
  details?: ClientErrorDetails;
  message: string;
  status: number;
}

/**
 * 0: 男性, 1: 女性, 2: その他
 */
export type UserSex = typeof UserSex[keyof typeof UserSex];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSex = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface EmploymentType {
  id: number;
  name: string;
}

export interface User {
  created_at?: string;
  /** 自己紹介 */
  description?: string;
  email: string;
  employmentType?: EmploymentType;
  id: number;
  image_url?: string;
  name: string;
  role?: Role;
  /** 0: 男性, 1: 女性, 2: その他 */
  sex?: UserSex;
  slack_id: string;
  updated_at?: string;
}

export interface Department {
  id: number;
  name: string;
}

export interface Role {
  department: Department;
  id: number;
  name: string;
}

export interface Restaurant {
  /** ホットペッパーAPIのID */
  api_stored_id: string;
  id: number;
}

/**
 * 0: 男性, 1: 女性, 2: その他
 */
export type EventScopeSex = typeof EventScopeSex[keyof typeof EventScopeSex];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventScopeSex = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface Event {
  /** SlackのチャンネルID */
  communication_ch_id?: string;
  created_at?: string;
  deadline?: string;
  description?: string;
  employment_types?: EmploymentType[];
  end_date: string;
  id?: number;
  image_url: string;
  is_anonymous: boolean;
  limit: number;
  organizer: User;
  restaurant?: Restaurant;
  roles?: Role[];
  /** 0: 男性, 1: 女性, 2: その他 */
  scope_sex?: EventScopeSex;
  start_date: string;
  title: string;
  updated_at?: string;
  users?: User[];
}

export interface LoginUrl {
  url: string;
}




type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * 初回表示時にこのAPIを叩いてセッションが有効か確認する
 * @summary 自分の情報を取得
 */
export const getMe = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUserResponse>(
      {url: `https://devsite.local/me`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/me`,options
    );
  }

>>>>>>> Stashed changes

export const getGetMeQueryKey = () => {
    return [`https://devsite.local/me`] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<AuthError | ServerError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = ErrorType<AuthError | ServerError>

/**
 * @summary 自分の情報を取得
 */
export const useGetMe = <TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<AuthError | ServerError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ログインURLを取得
 * @summary ログインURLを取得
 */
export const getLoginUrl = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginUrl>(
      {url: `https://devsite.local/login`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/login`,options
    );
  }

>>>>>>> Stashed changes

export const getGetLoginUrlQueryKey = () => {
    return [`https://devsite.local/login`] as const;
    }

    
export const getGetLoginUrlQueryOptions = <TData = Awaited<ReturnType<typeof getLoginUrl>>, TError = ErrorType<ServerError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLoginUrl>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLoginUrlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoginUrl>>> = ({ signal }) => getLoginUrl(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLoginUrl>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLoginUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getLoginUrl>>>
export type GetLoginUrlQueryError = ErrorType<ServerError>

/**
 * @summary ログインURLを取得
 */
export const useGetLoginUrl = <TData = Awaited<ReturnType<typeof getLoginUrl>>, TError = ErrorType<ServerError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLoginUrl>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLoginUrlQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * OAuth2のコールバック
 * @summary OAuth2のコールバック
 */
export const callback = (
<<<<<<< Updated upstream
    params: CallbackParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `https://devsite.local/callback`, method: 'GET',
        params, signal
    },
      options);
    }
  
=======
    params: CallbackParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.default.get(
      `https://devsite.local/callback`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

>>>>>>> Stashed changes

export const getCallbackQueryKey = (params: CallbackParams,) => {
    return [`https://devsite.local/callback`, ...(params ? [params]: [])] as const;
    }

    
export const getCallbackQueryOptions = <TData = Awaited<ReturnType<typeof callback>>, TError = ErrorType<void | ServerError>>(params: CallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof callback>>> = ({ signal }) => callback(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof callback>>, TError, TData> & { queryKey: QueryKey }
}

export type CallbackQueryResult = NonNullable<Awaited<ReturnType<typeof callback>>>
export type CallbackQueryError = ErrorType<void | ServerError>

/**
 * @summary OAuth2のコールバック
 */
export const useCallback = <TData = Awaited<ReturnType<typeof callback>>, TError = ErrorType<void | ServerError>>(
 params: CallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof callback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * イベントの一覧を取得
 * @summary イベントの一覧を取得
 */
export const getEvents = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetEventsResponse>(
      {url: `https://devsite.local/events`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/events`,options
    );
  }

>>>>>>> Stashed changes

export const getGetEventsQueryKey = () => {
    return [`https://devsite.local/events`] as const;
    }

    
export const getGetEventsQueryOptions = <TData = Awaited<ReturnType<typeof getEvents>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvents>>> = ({ signal }) => getEvents(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getEvents>>>
export type GetEventsQueryError = ErrorType<unknown>

/**
 * @summary イベントの一覧を取得
 */
export const useGetEvents = <TData = Awaited<ReturnType<typeof getEvents>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEventsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * イベントを作成
 * @summary イベントを作成
 */
export const postEvent = (
<<<<<<< Updated upstream
    postEventRequest: BodyType<PostEventRequest>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GetEventResponse>(
      {url: `https://devsite.local/events`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postEventRequest
    },
      options);
    }
  
=======
    postEventRequest: PostEventRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetEventResponse>> => {
    
    return axios.default.post(
      `https://devsite.local/events`,
      postEventRequest,options
    );
  }
>>>>>>> Stashed changes


export const getPostEventMutationOptions = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEvent>>, TError,{data: BodyType<PostEventRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postEvent>>, TError,{data: BodyType<PostEventRequest>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postEvent>>, {data: BodyType<PostEventRequest>}> = (props) => {
          const {data} = props ?? {};

          return  postEvent(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostEventMutationResult = NonNullable<Awaited<ReturnType<typeof postEvent>>>
    export type PostEventMutationBody = BodyType<PostEventRequest>
    export type PostEventMutationError = ErrorType<ClientError | ServerError>

    /**
 * @summary イベントを作成
 */
export const usePostEvent = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postEvent>>, TError,{data: BodyType<PostEventRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof postEvent>>,
        TError,
        {data: BodyType<PostEventRequest>},
        TContext
      > => {

      const mutationOptions = getPostEventMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * イベントの詳細を取得
 * @summary イベントの詳細を取得
 */
export const getEvent = (
<<<<<<< Updated upstream
    eventId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetEventResponse>(
      {url: `https://devsite.local/events/${eventId}`, method: 'GET', signal
    },
      options);
    }
  
=======
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetEventResponse>> => {
    
    return axios.default.get(
      `https://devsite.local/events/${eventId}`,options
    );
  }

>>>>>>> Stashed changes

export const getGetEventQueryKey = (eventId: string,) => {
    return [`https://devsite.local/events/${eventId}`] as const;
    }

    
export const getGetEventQueryOptions = <TData = Awaited<ReturnType<typeof getEvent>>, TError = ErrorType<ClientError | ServerError>>(eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvent>>> = ({ signal }) => getEvent(eventId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEventQueryResult = NonNullable<Awaited<ReturnType<typeof getEvent>>>
export type GetEventQueryError = ErrorType<ClientError | ServerError>

/**
 * @summary イベントの詳細を取得
 */
export const useGetEvent = <TData = Awaited<ReturnType<typeof getEvent>>, TError = ErrorType<ClientError | ServerError>>(
 eventId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEventQueryOptions(eventId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * イベントを更新
 * @summary イベントを更新
 */
export const putEvent = (
    eventId: string,
<<<<<<< Updated upstream
    postEventRequest: BodyType<PostEventRequest>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GetEventResponse>(
      {url: `https://devsite.local/events/${eventId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: postEventRequest
    },
      options);
    }
  
=======
    postEventRequest: PostEventRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetEventResponse>> => {
    
    return axios.default.put(
      `https://devsite.local/events/${eventId}`,
      postEventRequest,options
    );
  }
>>>>>>> Stashed changes


export const getPutEventMutationOptions = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEvent>>, TError,{eventId: string;data: BodyType<PostEventRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putEvent>>, TError,{eventId: string;data: BodyType<PostEventRequest>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putEvent>>, {eventId: string;data: BodyType<PostEventRequest>}> = (props) => {
          const {eventId,data} = props ?? {};

          return  putEvent(eventId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutEventMutationResult = NonNullable<Awaited<ReturnType<typeof putEvent>>>
    export type PutEventMutationBody = BodyType<PostEventRequest>
    export type PutEventMutationError = ErrorType<ClientError | ServerError>

    /**
 * @summary イベントを更新
 */
export const usePutEvent = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEvent>>, TError,{eventId: string;data: BodyType<PostEventRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof putEvent>>,
        TError,
        {eventId: string;data: BodyType<PostEventRequest>},
        TContext
      > => {

      const mutationOptions = getPutEventMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * イベントを削除
 * @summary イベントを削除
 */
export const deleteEvent = (
<<<<<<< Updated upstream
    eventId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GetEventResponse>(
      {url: `https://devsite.local/events/${eventId}`, method: 'DELETE'
    },
      options);
    }
  
=======
    eventId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetEventResponse>> => {
    
    return axios.default.delete(
      `https://devsite.local/events/${eventId}`,options
    );
  }
>>>>>>> Stashed changes


export const getDeleteEventMutationOptions = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEvent>>, TError,{eventId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEvent>>, TError,{eventId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEvent>>, {eventId: string}> = (props) => {
          const {eventId} = props ?? {};

          return  deleteEvent(eventId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEventMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEvent>>>
    
    export type DeleteEventMutationError = ErrorType<ClientError | ServerError>

    /**
 * @summary イベントを削除
 */
export const useDeleteEvent = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEvent>>, TError,{eventId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteEvent>>,
        TError,
        {eventId: string},
        TContext
      > => {

      const mutationOptions = getDeleteEventMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 特定のイベントに特定のユーザーが参加申し込みをします。
 * @summary イベントに参加申し込みをする
 */
export const joinEvent = (
    eventId: number,
<<<<<<< Updated upstream
    joinEventRequest: BodyType<JoinEventRequest>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<JoinEventResponse>(
      {url: `https://devsite.local/events/${eventId}/participants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: joinEventRequest
    },
      options);
    }
  
=======
    joinEventRequest: JoinEventRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JoinEventResponse>> => {
    
    return axios.default.post(
      `https://devsite.local/events/${eventId}/participants`,
      joinEventRequest,options
    );
  }
>>>>>>> Stashed changes


export const getJoinEventMutationOptions = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinEvent>>, TError,{eventId: number;data: BodyType<JoinEventRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof joinEvent>>, TError,{eventId: number;data: BodyType<JoinEventRequest>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joinEvent>>, {eventId: number;data: BodyType<JoinEventRequest>}> = (props) => {
          const {eventId,data} = props ?? {};

          return  joinEvent(eventId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type JoinEventMutationResult = NonNullable<Awaited<ReturnType<typeof joinEvent>>>
    export type JoinEventMutationBody = BodyType<JoinEventRequest>
    export type JoinEventMutationError = ErrorType<ClientError | ServerError>

    /**
 * @summary イベントに参加申し込みをする
 */
export const useJoinEvent = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinEvent>>, TError,{eventId: number;data: BodyType<JoinEventRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof joinEvent>>,
        TError,
        {eventId: number;data: BodyType<JoinEventRequest>},
        TContext
      > => {

      const mutationOptions = getJoinEventMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ユーザーの詳細を取得
 * @summary ユーザーの詳細を取得
 */
export const getUser = (
<<<<<<< Updated upstream
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUserResponse>(
      {url: `https://devsite.local/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  
=======
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserResponse>> => {
    
    return axios.default.get(
      `https://devsite.local/users/${userId}`,options
    );
  }

>>>>>>> Stashed changes

export const getGetUserQueryKey = (userId: string,) => {
    return [`https://devsite.local/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<ClientError | ServerError>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorType<ClientError | ServerError>

/**
 * @summary ユーザーの詳細を取得
 */
export const useGetUser = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<ClientError | ServerError>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ユーザーを更新
 * @summary ユーザーを更新
 */
export const putUser = (
    userId: string,
<<<<<<< Updated upstream
    putUserRequest: BodyType<PutUserRequest>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GetUserResponse>(
      {url: `https://devsite.local/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putUserRequest
    },
      options);
    }
  
=======
    putUserRequest: PutUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserResponse>> => {
    
    return axios.default.put(
      `https://devsite.local/users/${userId}`,
      putUserRequest,options
    );
  }
>>>>>>> Stashed changes


export const getPutUserMutationOptions = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUser>>, TError,{userId: string;data: BodyType<PutUserRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putUser>>, TError,{userId: string;data: BodyType<PutUserRequest>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putUser>>, {userId: string;data: BodyType<PutUserRequest>}> = (props) => {
          const {userId,data} = props ?? {};

          return  putUser(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutUserMutationResult = NonNullable<Awaited<ReturnType<typeof putUser>>>
    export type PutUserMutationBody = BodyType<PutUserRequest>
    export type PutUserMutationError = ErrorType<ClientError | ServerError>

    /**
 * @summary ユーザーを更新
 */
export const usePutUser = <TError = ErrorType<ClientError | ServerError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUser>>, TError,{userId: string;data: BodyType<PutUserRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof putUser>>,
        TError,
        {userId: string;data: BodyType<PutUserRequest>},
        TContext
      > => {

      const mutationOptions = getPutUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * レストランの一覧を取得
 * @summary レストランの一覧を取得
 */
export const getRestaurants = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRestaurantsResponse>(
      {url: `https://devsite.local/restaurants`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/restaurants`,options
    );
  }

>>>>>>> Stashed changes

export const getGetRestaurantsQueryKey = () => {
    return [`https://devsite.local/restaurants`] as const;
    }

    
export const getGetRestaurantsQueryOptions = <TData = Awaited<ReturnType<typeof getRestaurants>>, TError = ErrorType<ClientError | ServerError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRestaurants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRestaurantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRestaurants>>> = ({ signal }) => getRestaurants(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRestaurants>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRestaurantsQueryResult = NonNullable<Awaited<ReturnType<typeof getRestaurants>>>
export type GetRestaurantsQueryError = ErrorType<ClientError | ServerError>

/**
 * @summary レストランの一覧を取得
 */
export const useGetRestaurants = <TData = Awaited<ReturnType<typeof getRestaurants>>, TError = ErrorType<ClientError | ServerError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRestaurants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRestaurantsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 部署の一覧を取得
 * @summary 部署の一覧を取得
 */
export const getDepartments = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDepartmentsResponse>(
      {url: `https://devsite.local/departments`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/departments`,options
    );
  }

>>>>>>> Stashed changes

export const getGetDepartmentsQueryKey = () => {
    return [`https://devsite.local/departments`] as const;
    }

    
export const getGetDepartmentsQueryOptions = <TData = Awaited<ReturnType<typeof getDepartments>>, TError = ErrorType<ClientError | ServerError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepartmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepartments>>> = ({ signal }) => getDepartments(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepartments>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDepartmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getDepartments>>>
export type GetDepartmentsQueryError = ErrorType<ClientError | ServerError>

/**
 * @summary 部署の一覧を取得
 */
export const useGetDepartments = <TData = Awaited<ReturnType<typeof getDepartments>>, TError = ErrorType<ClientError | ServerError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepartments>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDepartmentsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 役職の一覧を取得
 * @summary 役職の一覧を取得
 */
export const getRoles = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRolesResponse>(
      {url: `https://devsite.local/roles`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/roles`,options
    );
  }

>>>>>>> Stashed changes

export const getGetRolesQueryKey = () => {
    return [`https://devsite.local/roles`] as const;
    }

    
export const getGetRolesQueryOptions = <TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorType<ClientError | ServerError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoles>>> = ({ signal }) => getRoles(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getRoles>>>
export type GetRolesQueryError = ErrorType<ClientError | ServerError>

/**
 * @summary 役職の一覧を取得
 */
export const useGetRoles = <TData = Awaited<ReturnType<typeof getRoles>>, TError = ErrorType<ClientError | ServerError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRolesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 雇用形態の一覧を取得
 * @summary 雇用形態の一覧を取得
 */
export const getEmploymentTypes = (
    
<<<<<<< Updated upstream
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetEmploymentTypesResponse>(
      {url: `https://devsite.local/employment_types`, method: 'GET', signal
    },
      options);
    }
  
=======
    return axios.default.get(
      `https://devsite.local/employment_types`,options
    );
  }

>>>>>>> Stashed changes

export const getGetEmploymentTypesQueryKey = () => {
    return [`https://devsite.local/employment_types`] as const;
    }

    
export const getGetEmploymentTypesQueryOptions = <TData = Awaited<ReturnType<typeof getEmploymentTypes>>, TError = ErrorType<ClientError | ServerError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmploymentTypes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEmploymentTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmploymentTypes>>> = ({ signal }) => getEmploymentTypes(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEmploymentTypes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEmploymentTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getEmploymentTypes>>>
export type GetEmploymentTypesQueryError = ErrorType<ClientError | ServerError>

/**
 * @summary 雇用形態の一覧を取得
 */
export const useGetEmploymentTypes = <TData = Awaited<ReturnType<typeof getEmploymentTypes>>, TError = ErrorType<ClientError | ServerError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEmploymentTypes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEmploymentTypesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}






export const getGetMeResponseMock = (overrideResponse: Partial< GetUserResponse > = {}): GetUserResponse => ({user: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, ...overrideResponse})

export const getGetLoginUrlResponseMock = (overrideResponse: Partial< LoginUrl > = {}): LoginUrl => ({url: faker.word.sample(), ...overrideResponse})

export const getGetEventsResponseMock = (overrideResponse: Partial< GetEventsResponse > = {}): GetEventsResponse => ({events: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({communication_ch_id: faker.helpers.arrayElement([faker.word.sample(), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), deadline: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), employment_types: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), end_date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), image_url: faker.word.sample(), is_anonymous: faker.datatype.boolean(), limit: faker.number.int({min: undefined, max: undefined}), organizer: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, restaurant: faker.helpers.arrayElement([{api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})}, undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), scope_sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), start_date: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])})), ...overrideResponse})

export const getPostEventResponseMock = (overrideResponse: Partial< GetEventResponse > = {}): GetEventResponse => ({event: {communication_ch_id: faker.helpers.arrayElement([faker.word.sample(), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), deadline: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), employment_types: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), end_date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), image_url: faker.word.sample(), is_anonymous: faker.datatype.boolean(), limit: faker.number.int({min: undefined, max: undefined}), organizer: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, restaurant: faker.helpers.arrayElement([{api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})}, undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), scope_sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), start_date: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])}, ...overrideResponse})

export const getGetEventResponseMock = (overrideResponse: Partial< GetEventResponse > = {}): GetEventResponse => ({event: {communication_ch_id: faker.helpers.arrayElement([faker.word.sample(), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), deadline: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), employment_types: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), end_date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), image_url: faker.word.sample(), is_anonymous: faker.datatype.boolean(), limit: faker.number.int({min: undefined, max: undefined}), organizer: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, restaurant: faker.helpers.arrayElement([{api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})}, undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), scope_sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), start_date: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])}, ...overrideResponse})

export const getPutEventResponseMock = (overrideResponse: Partial< GetEventResponse > = {}): GetEventResponse => ({event: {communication_ch_id: faker.helpers.arrayElement([faker.word.sample(), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), deadline: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), employment_types: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), end_date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), image_url: faker.word.sample(), is_anonymous: faker.datatype.boolean(), limit: faker.number.int({min: undefined, max: undefined}), organizer: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, restaurant: faker.helpers.arrayElement([{api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})}, undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), scope_sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), start_date: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])}, ...overrideResponse})

export const getDeleteEventResponseMock = (overrideResponse: Partial< GetEventResponse > = {}): GetEventResponse => ({event: {communication_ch_id: faker.helpers.arrayElement([faker.word.sample(), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), deadline: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), employment_types: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), end_date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), image_url: faker.word.sample(), is_anonymous: faker.datatype.boolean(), limit: faker.number.int({min: undefined, max: undefined}), organizer: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, restaurant: faker.helpers.arrayElement([{api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})}, undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), scope_sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), start_date: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])}, ...overrideResponse})

export const getJoinEventResponseMock = (overrideResponse: Partial< JoinEventResponse > = {}): JoinEventResponse => ({event: faker.helpers.arrayElement([{communication_ch_id: faker.helpers.arrayElement([faker.word.sample(), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), deadline: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), employment_types: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), end_date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), image_url: faker.word.sample(), is_anonymous: faker.datatype.boolean(), limit: faker.number.int({min: undefined, max: undefined}), organizer: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, restaurant: faker.helpers.arrayElement([{api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})}, undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), undefined]), scope_sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), start_date: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])}, undefined]), ...overrideResponse})

export const getGetUserResponseMock = (overrideResponse: Partial< GetUserResponse > = {}): GetUserResponse => ({user: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, ...overrideResponse})

export const getPutUserResponseMock = (overrideResponse: Partial< GetUserResponse > = {}): GetUserResponse => ({user: {created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), description: faker.helpers.arrayElement([faker.word.sample(), undefined]), email: faker.word.sample(), employmentType: faker.helpers.arrayElement([{id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), id: faker.number.int({min: undefined, max: undefined}), image_url: faker.helpers.arrayElement([faker.word.sample(), undefined]), name: faker.word.sample(), role: faker.helpers.arrayElement([{department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, undefined]), sex: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), slack_id: faker.word.sample(), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, ...overrideResponse})

export const getGetRestaurantsResponseMock = (overrideResponse: Partial< GetRestaurantsResponse > = {}): GetRestaurantsResponse => ({restaurants: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({api_stored_id: faker.word.sample(), id: faker.number.int({min: undefined, max: undefined})})), ...overrideResponse})

export const getGetDepartmentsResponseMock = (overrideResponse: Partial< GetDepartmentsResponse > = {}): GetDepartmentsResponse => ({departments: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), ...overrideResponse})

export const getGetRolesResponseMock = (overrideResponse: Partial< GetRolesResponse > = {}): GetRolesResponse => ({roles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({department: {id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()}, id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), ...overrideResponse})

export const getGetEmploymentTypesResponseMock = (overrideResponse: Partial< GetEmploymentTypesResponse > = {}): GetEmploymentTypesResponse => ({employmentTypes: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.word.sample()})), ...overrideResponse})


export const getGetMeMockHandler = (overrideResponse?: GetUserResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetUserResponse)) => {
  return http.get('*/me', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetMeResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetLoginUrlMockHandler = (overrideResponse?: LoginUrl | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => LoginUrl)) => {
  return http.get('*/login', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetLoginUrlResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCallbackMockHandler = () => {
  return http.get('*/callback', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetEventsMockHandler = (overrideResponse?: GetEventsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetEventsResponse)) => {
  return http.get('*/events', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetEventsResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getPostEventMockHandler = (overrideResponse?: GetEventResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => GetEventResponse)) => {
  return http.post('*/events', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getPostEventResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetEventMockHandler = (overrideResponse?: GetEventResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetEventResponse)) => {
  return http.get('*/events/:eventId', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetEventResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getPutEventMockHandler = (overrideResponse?: GetEventResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => GetEventResponse)) => {
  return http.put('*/events/:eventId', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getPutEventResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteEventMockHandler = (overrideResponse?: GetEventResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => GetEventResponse)) => {
  return http.delete('*/events/:eventId', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getDeleteEventResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getJoinEventMockHandler = (overrideResponse?: JoinEventResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => JoinEventResponse)) => {
  return http.post('*/events/:eventId/participants', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getJoinEventResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetUserMockHandler = (overrideResponse?: GetUserResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetUserResponse)) => {
  return http.get('*/users/:userId', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetUserResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getPutUserMockHandler = (overrideResponse?: GetUserResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => GetUserResponse)) => {
  return http.put('*/users/:userId', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getPutUserResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetRestaurantsMockHandler = (overrideResponse?: GetRestaurantsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetRestaurantsResponse)) => {
  return http.get('*/restaurants', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetRestaurantsResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetDepartmentsMockHandler = (overrideResponse?: GetDepartmentsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetDepartmentsResponse)) => {
  return http.get('*/departments', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetDepartmentsResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetRolesMockHandler = (overrideResponse?: GetRolesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetRolesResponse)) => {
  return http.get('*/roles', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetRolesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetEmploymentTypesMockHandler = (overrideResponse?: GetEmploymentTypesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => GetEmploymentTypesResponse)) => {
  return http.get('*/employment_types', async (info) => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? overrideResponse(info) : overrideResponse) 
            : getGetEmploymentTypesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}
export const getGohanSchemaMock = () => [
  getGetMeMockHandler(),
  getGetLoginUrlMockHandler(),
  getCallbackMockHandler(),
  getGetEventsMockHandler(),
  getPostEventMockHandler(),
  getGetEventMockHandler(),
  getPutEventMockHandler(),
  getDeleteEventMockHandler(),
  getJoinEventMockHandler(),
  getGetUserMockHandler(),
  getPutUserMockHandler(),
  getGetRestaurantsMockHandler(),
  getGetDepartmentsMockHandler(),
  getGetRolesMockHandler(),
  getGetEmploymentTypesMockHandler()
]
